auth-server already defines an M2M client (oerms-m2m) — that means we can (and should) use client_credentials to get a machine token and use that in Feign calls from attempt-service (and other services). Two final things to make this work end-to-end:

Ensure the machine token has the authority the internal endpoint expects (scope or role).

Implement a token manager + Feign interceptor inside the caller service (attempt-service) — not the common module.

Below I give a compact, copy-pasteable solution you can drop into attempt-service (or any service that needs to call internal APIs).

1) Make the machine client usable for internal calls

You already registered oerms-m2m with scopes read and write. I recommend adding an explicit internal scope (or role) so the question-service can require it:

In auth-server RegisteredClient m2mClient add .scope("internal") (and/or a ROLE_SYSTEM claim).

If you prefer not to change the client, we will map scopes to authorities — more on that below.

2) Add properties to attempt-service application.yml
oauth2:
  client:
    token-uri: http://localhost:9000/oauth2/token        # auth-server token endpoint
    client-id: oerms-m2m
    client-secret: supersecret
    scope: internal                                      # optional: request internal scope


Adjust token-uri to whatever your gateway/auth URL is (eg http://auth-server/oauth2/token if using discovery).

3) Token manager (attempt-service)

A thread-safe cached client credentials token fetcher using WebClient. Put this class in com.oerms.attempt.security (or similar).

package com.oerms.attempt.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Instant;
import java.util.Map;

@Slf4j
@Component
@RequiredArgsConstructor
public class OAuth2ClientCredentialsManager {

    private final WebClient.Builder webClientBuilder;

    @Value("${oauth2.client.token-uri}")
    private String tokenUri;

    @Value("${oauth2.client.client-id}")
    private String clientId;

    @Value("${oauth2.client.client-secret}")
    private String clientSecret;

    @Value("${oauth2.client.scope:}") // optional
    private String scope;

    private volatile String accessToken;
    private volatile Instant expiry;

    public synchronized String getToken() {
        if (accessToken == null || Instant.now().isAfter(expiry)) {
            log.debug("Fetching new client_credentials token for clientId={}", clientId);

            String form = "grant_type=client_credentials&client_id=" + encode(clientId)
                    + "&client_secret=" + encode(clientSecret);
            if (scope != null && !scope.isBlank()) {
                form += "&scope=" + encode(scope);
            }

            Map<String, Object> resp = webClientBuilder.build()
                    .post()
                    .uri(tokenUri)
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .body(BodyInserters.fromValue(form))
                    .retrieve()
                    .bodyToMono(Map.class)
                    .block();

            if (resp == null || resp.get("access_token") == null) {
                throw new IllegalStateException("Failed to obtain client_credentials token");
            }

            accessToken = (String) resp.get("access_token");
            Number expiresIn = (Number) resp.getOrDefault("expires_in", 3600);
            expiry = Instant.now().plusSeconds(expiresIn.longValue() - 20);
            log.debug("Fetched M2M token, expiresIn={}s", expiresIn);
        }
        return accessToken;
    }

    private static String encode(String v) {
        return java.net.URLEncoder.encode(v, java.nio.charset.StandardCharsets.UTF_8);
    }
}

4) Feign interceptor (attempt-service)

This interceptor always injects the machine token (so Feign calls work even when SecurityContext is null).

package com.oerms.attempt.config;

import com.oerms.attempt.security.OAuth2ClientCredentialsManager;
import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class FeignM2MConfig {

    private final OAuth2ClientCredentialsManager tokenManager;

    @Bean
    public RequestInterceptor m2mRequestInterceptor() {
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate template) {
                String token = tokenManager.getToken();
                template.header("Authorization", "Bearer " + token);
            }
        };
    }
}


Use this config for Feign clients that must call internal endpoints. Example usage on the Feign client:

@FeignClient(name = "question-service", path = "/api/questions", configuration = FeignM2MConfig.class)
public interface QuestionServiceClient { ... }


Important: only apply the M2M Feign config to clients that must use machine token (internal calls). For external calls where frontend token should be forwarded, keep the SecurityContext-based interceptor.

5) Optional: Dual-behaviour approach (forward student token for public endpoints, use M2M for internal)

If a service sometimes needs to forward the incoming user's JWT (e.g., public student endpoints) but for internal endpoints must use M2M:

Keep your existing SecurityContext-based interceptor in FeignClientConfig (that extracts JWT from SecurityContextHolder) and put it as default for most clients.

For internal endpoints (like /internal/** or /batch), create separate Feign client interfaces configured with FeignM2MConfig.class. This way internal calls use M2M always.

6) Make sure auth-server issues the right authorities for machine tokens

Two approaches (choose one):

A — Add roles/authorities claim to client tokens

Modify oauth2TokenCustomizer in your auth-server to add roles or authorities when the token is created for a client (client_credentials grant). Example:

import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;
import org.springframework.security.oauth2.server.authorization.authentication.OAuth2ClientAuthenticationToken;
import org.springframework.security.oauth2.server.authorization.token.JwtEncodingContext;

@Bean
public OAuth2TokenCustomizer<JwtEncodingContext> jwtCustomizer(UserRepository repo) {
    return context -> {
        if (context.getTokenType().getValue().equals("access_token")) {
            var principal = context.getPrincipal();
            // user token
            if (principal != null && principal.getPrincipal() instanceof org.springframework.security.core.userdetails.User) {
                // existing user-based logic...
            }
            // client_credentials token
            if (principal instanceof OAuth2ClientAuthenticationToken clientAuth) {
                String clientId = clientAuth.getPrincipal().toString();
                // for example, add a roles claim for this client
                if ("oerms-m2m".equals(clientId)) {
                    context.getClaims().claim("roles", List.of("ROLE_SYSTEM"));
                }
                // also add scopes as claim if you want:
                context.getClaims().claim("scope", clientAuth.getScopes());
            }
        }
    };
}


This makes machine tokens carry roles or scope so your resource servers can map them to authorities.

B — Map scope claim to authorities at resource servers

Your resource-server currently uses:

grantedAuthoritiesConverter.setAuthoritiesClaimName("roles");
grantedAuthoritiesConverter.setAuthorityPrefix("");


Update resource servers (attempt/exam/question) to aggregate both roles and scope (scope or scp) into authorities. Example converter:

@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter scopeConverter = new JwtGrantedAuthoritiesConverter();
    // keep default behavior for scopes (adds SCOPE_ prefix). We will remove prefix later.
    // We also want roles claim
    JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
    converter.setJwtGrantedAuthoritiesConverter(jwt -> {
        Collection<GrantedAuthority> authorities = new ArrayList<>();
        // roles claim
        Object rolesClaim = jwt.getClaim("roles");
        if (rolesClaim instanceof Collection) {
            ((Collection<?>) rolesClaim).forEach(r -> authorities.add(new SimpleGrantedAuthority(String.valueOf(r))));
        }
        // scopes
        Collection<GrantedAuthority> scopeAuthorities = scopeConverter.convert(jwt);
        // convert SCOPE_foo to foo (or keep as SCOPE_*)
        authorities.addAll(scopeAuthorities);
        return authorities;
    });
    return converter;
}


If you prefer roles without SCOPE_ prefix, you can strip it.

I recommend A + B: add a roles claim for the M2M client and also accept scope in resource servers. That gives maximum flexibility.

7) Protect internal endpoints in question-service

Change Question-Service security to require either ROLE_SYSTEM or SCOPE_internal for /api/questions/internal/**:

Example (in question-service SecurityConfig):

.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/questions/internal/**").hasAuthority("ROLE_SYSTEM")
    // or hasAuthority("SCOPE_internal") depending on your authority mapping
    ...
)

8) Testing checklist

From a shell or Postman, get machine token:

curl -s -X POST http://localhost:9000/oauth2/token \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "grant_type=client_credentials&client_id=oerms-m2m&client_secret=supersecret&scope=internal" \
| jq


Verify token contains scope and/or roles claim.

Call question-service internal endpoint with that token:

curl -H "Authorization: Bearer <TOKEN>" http://localhost:9003/api/questions/internal/batch


Should return 200/authorized (or expected response).

Start an attempt in the UI — server Feign should now call question-service using M2M token and not student token.

9) Quick summary (what you must change right now)

Add M2M token manager + FeignM2MConfig into attempt-service (code above).

Ensure your @FeignClient for internal batch call uses configuration = FeignM2MConfig.class.

Make sure oerms-m2m client has scope/role that question-service accepts (add internal scope or add roles claim in token).

Update question-service resource server or registered client claims mapping so that client token maps to required authority (either via jwtCustomizer on auth-server or via resource server converter).