1	"admin"	"admin@oerms.com"	"$2a$10$tW2a7bGbIanh4JQdN0l3uO3mnqjemt45YsxXk5l09Q9ZxtkDe4CTK"	"System"	"Admin"	true	true	true	true	"2025-11-13 21:59:44.192753"	"2025-11-13 21:59:44.192753"
2	"teacher"	"teacher@oerms.com"	"$2a$10$4WYJMD68epVfgb6DYNWbQ.qKtq3HA.lSKa2XUq6uaqQvu5i5uTpyq"	"Default"	"Teacher"	true	true	true	true	"2025-11-13 21:59:44.192753"	"2025-11-13 21:59:44.192753"
3	"student"	"student@oerms.com"	"$2a$10$ePoWzmFSEzOBC1QCDx4hmO9./w0151dxU1/9xzENGC6piyGK3IouG"	"Default"	"Student"	true	true	true	true	"2025-11-13 21:59:44.192753"	"2025-11-13 21:59:44.192753"



import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import java.net.URI;

@RestController
@Slf4j
public class MyAuthController {
    private final TokenBlacklistService tokenBlacklistService;

    @Autowired
    public MyAuthController(TokenBlacklistService tokenBlacklistService) {
        this.tokenBlacklistService = tokenBlacklistService;
    }

    @PostMapping("/logout")
    @PreAuthorize("isAuthenticated()")
    @SecurityRequirement(name = "Bearer Authentication")
    @Operation(summary = "Logout", description = "Logout the current user (invalidate tokens)")
    public ResponseEntity<Void> logout(HttpServletRequest request) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String email = authentication.getName();

        log.info("Logout request for user: {}", email);

        // Extract token from Authorization header and blacklist it
        String authorizationHeader = request.getHeader(HttpHeaders.AUTHORIZATION);
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            String token = authorizationHeader.substring(7);
            tokenBlacklistService.blacklistToken(token); // Call the service to invalidate the token
        } else {
            log.warn("No Bearer token found in Authorization header for user {}. Cannot blacklist specific token.", email);
            // Optionally, if only email-based session invalidation is used:
            // tokenBlacklistService.invalidateUserSessions(email);
        }

        // Redirect to the specified URL
        HttpHeaders headers = new HttpHeaders();
        // The user specifically requested "http://localhost:3000"
        headers.setLocation(URI.create("http://localhost:3000"));
        log.info("Redirecting user {} to {}", email, "http://localhost:3000");

        // HttpStatus.SEE_OTHER (303) is generally recommended after a POST request
        // to tell the client to issue a GET request to the new URI.
        return new ResponseEntity<>(headers, HttpStatus.SEE_OTHER);
    }
}

@Service
@Slf4j
class TokenBlacklistService {
    public void blacklistToken(String token) {
        // In a real application, this would store the token (or its JTI) in a database or cache
        // with an expiration time matching the token's original expiration.
        // For demonstration, we just log it.
        log.info("Token blacklisted (simulated): {}...", token.substring(0, Math.min(token.length(), 20)));
    }

    public void invalidateUserSessions(String email) {
        // This could be used in a session-based system or for revoking all tokens for a user
        log.info("All sessions for user {} invalidated (simulated).", email);
    }
}

@Bean
public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
    OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
            new OAuth2AuthorizationServerConfigurer();

    // Enable OpenID Connect 1.0 (this includes the Logout endpoint)
    authorizationServerConfigurer.oidc(oidc -> oidc
        .clientRegistrationEndpoint(Customizer.withDefaults())
        .providerConfigurationEndpoint(Customizer.withDefaults())
    );

    RequestMatcher endpointsMatcher = authorizationServerConfigurer.getEndpointsMatcher();

    http
        .securityMatcher(endpointsMatcher)
        .authorizeHttpRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .csrf(csrf -> csrf.ignoringRequestMatchers(endpointsMatcher))
        .apply(authorizationServerConfigurer);

    // ... other config ...

    return http.build();
}